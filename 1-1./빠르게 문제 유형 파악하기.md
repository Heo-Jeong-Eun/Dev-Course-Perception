## 2. 빠르게 문제 유형 파악하기

> **빠르게 문제 유형 파악하기** 
> 
> - 문제를 자세히 읽기 전에 **입출력 제한을 보는 것**이 중요하다.
> - **입력 제한**을 보면 어떤 **시간복잡도** 내에 풀어야하는지 알 수 있다.
>     - 입력이 100 이하인 경우
>         - 완전 탐색
>         - 백트래킹
>     - 입력이 1000 이하인 경우
>         - 최대 O(N^2) 이내로 끝내야하는 문제
>         - 문제에 따라 O(N^2 log N)까지는 허용
>         - N * N 2차원 리스트를 모두 순회해야하는 문제가 많다.
>     - 입력이 1000000 이하인 경우
>         - 최대 O(N log N)으로 끝내야하는 문제
>         - 힙, 우선순위 큐
>         - 동적 계획법
>         - 위상 정렬
>         - 다익스트라 알고리즘
>     - 입력이 100000000 이하인 경우
>         - 최대 O(N)으로 끝내야하는 문제
>         - 동적 계획법
>         - 그리디
>     - 그 이상인 경우
>         - 최대 O(log N)으로 끝내야하는 문제가 많다.
>         - 이진 탐색
>         - 거의 나오지 않는 문제 유형이다.
> - 문제 유형
>     - **입력값이 작은 문제**
>         - 높은 확률로 **완전 탐색, 백트래킹 문제**이다.
>         - **구현력**이 중요한 문제로 출제될 가능성이 높다.
>     - **지도가 주어지고 채워진 영역을 찾아야하는 경우**
>         - 높은 확률로 **BFS, DFS 문제**이다.
>         - FloodFill과 같이 정직한 방식으로 나오거나 전염병 문제나 치즈 문제([https://www.acmicpc.net/problem/2636](https://www.acmicpc.net/problem/2636))처럼 변형되서 나오는 경우가 있다.
>     - **그래프 그림이 있는 경우**
>         - **최단 거리 찾기**
>         - **최소 신장 트리**
>             - 최소 신장 트리 문제는 보통 "가장 저렴한 방법으로 모든 경로 연결해라" 등의 키워드로 출제된다.
>             - 경로가 아니라 통신망, 전송 시간, 회로, 배관 등 다양한 용어로 나올 수는 있지만 핵심은 모든 경로를 ‘가장 싸게 연결해라’이다.
>             - 그래프는 양방향일수도 단방향일수도 있다.
>             - 크루스칼, 프림 알고리즘을 사용할 수 있습니다.
>         - **위상 정렬**
>             - 문제에서 ‘가장 빠른 길’, ‘최단 거리’와 비슷한 키워드가 나온다면 당연히 최단 거리 찾기 유형이고 ‘X 비용 내로 갈 수 있는 길을 찾아라’와 같은 키워드가 나와도 최단 거리 찾기 유형이다.
>             - 다익스트라, BFS, DFS 등이 사용될 수 있다.
>     - **X라는 조건을 만족하는 가장 최대 / 최소 값을 찾는 문제** 
>         - 높은 확률로 **결정 문제**이다.
>         - 파라메트릭 서치를 이용해 풀 수 있다.
>     - **실시간으로 정렬이 이루어져야 하는 경우**
>         - **우선순위 큐 혹은 힙**을 사용하는 문제이다.
>     - **DP 문제**
>         - 보통 **완전 탐색처럼 시간이 오래걸리면 안되는데 특별한 알고리즘을 사용하는 문제가 아닐거 같을 때는 높은 확률로 DP 문제**이다.
>         - 다른 문제처럼 ‘딱 이거네’ 하는 특징이 없어서 보통 문제를 보고 바로 유형을 판단하기 힘든 경우 DP처럼 풀 수 있는지 생각해야한다.
>             1. 문제를 따라 먼저 초기값을 적는다.
>             2. 초기값을 포함해 모든 상태값을 적는다.
>             3. 현재상태를 통해 다음 값을 구할 수 있는지 판단한다.
>             4. 혹은 이전 상태들을 통해 현재 값을 구할 수 있는지 판단한다.
>         - 이런식으로 여러 번 해보고 식을 만들 수 있다면 100% DP 문제이다.
>     - **문자열이 주어지는 경우**
>         - **구현력 문제**인 경우가 많다.
>         - 문자열을 자르거나, 붙이거나 탐색하는 문제가 대부분이다.
>         - 문자열을 탐색하는 알고리즘이 필요한 경우 **KMP 알고리즘**을 사용할 수 있지만 보통 파이썬과 같은 스크립트 언어에선 문자열 탐색이 빌트인으로 존재하기 때문에 구현에만 집중하면 된다.
>     - **현재 상황에서 가장 최적인 선택을 하는 경우**
>         - 문제에서 항상 최적의 선택을 해야하는 경우 혹은 ‘가장 많은 선택을 할 수 있는’, ‘가장 작은 / 큰’ 등의 키워드가 들어가면 그리디 문제일 가능성이 높다.
>         - 최소 신장 트리도 그리디의 일종이다.